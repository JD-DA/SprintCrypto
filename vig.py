message="""%jGbnzkcvv jg bwbhtsa

Ttg gbnzkcv kk pcumxgg mvz wbm vzchqzt tolfu qbljy eccwzgg l'zxkuqak
kbkjxvoqak. Wbm vzchqzt fs kj mgbzj ésgh oéaéxczmbkph ljy uiquku rm auopzjy qi
lj rghbwku gwtbgbb hxqixév vcf 5, kzjéu sv Butgm za gb icvjojjz tolfu. Nczv jgg
éufyuwway rvwaosimv, igg aéxagbkjy ucvu étqbkéjy roz kku jwfd cfbflkqqjrnsa. Fr
glqvzg rmv yvobfupg lj tqajwku riay fs vzsdfmtygg tntiimv.

Igg éufyuwway usznogbb kkuhqaéku à rmv gehqsovég l'jyrwwatcum, bgkg kjz wgihk
p'o rnscwa éué iqbnfxoé dcmrkecjsgbb ygt iv huwjmwtgamaz uialkrhqmrg rm igkfm
iupqbfupbmw aps bjrns augvwwa. Kp fmsgpqpj, rgg Ébnzu-Ivfy qbb eaié sv 2001 cku
Qcmgp Tqsk, wb owuwdm k'oprqsofia jyrwwatcbb yuwf tj iqaxuk fs Kthc sb xak
fmlkxoqjtv sb kéiqrifkph ljy osavgisa kohtcvéy fsxtou ivj yvobfup rm auopzjy
eijnops1.

Tjy uhiuoqba kk pcumxgg v'ébkvhmaz roa jt ecvuopi. Mcrgg iyvcfifyusvu kv
rqvvcfifyusvu gw tqc jw hmbvu gcw jkjmwygg nwéwwsvlku (uévéwgnsujtv rc vvgqbwk
JT), unou qmwzcwvjy uiqskph kjvgblntv iv yxquznsos zéhanwmw. Rgiz nivwdfzé c
ochsgbbé à ygthqw jg 1960 odntv rm lnwhmw à rc gcfzg rm c'éinobjsgbb kk n'Ivfup
gwsoévwytk.

%jPcuy

Ustzt Vvm Lupsb Yxqxmlz, nsa vzchqztu rm auopzjy glqvzgbb kkriqv rc Dzjskèfm
Hagfzj sqblfgns. Af ighbj ghtqwschqzt ggb jdcqbj, rgg augvwway fs vzsdfmv
iqaxukph xnxow tjy rfmboètsa uxcbabougqztu fikoq.

Wt n ézé udéktré sim lku gbnzkcvv ygfdjtv à rmv gisvlku uwtbgfvjsgbbnrgg xzat
hzntuamuzts ljy osavgisa à kku sayoqba, kk hoçwa ykaxck gh milkqilk. Ustzt
esbuk vvéwwog, zmv sgganmgg aztv qpflhféa nbgq ca scgytk lsbnhns. Cak cibwk
vvéwwog gcyvqgm xag qmwzcwvjy fsa vzchqztu gwaz nwémv à jgg wyéxchqztu rm
uxctql jg rzzmws.

%pKétqaqagvwway

Nsa vzchqztu rm auopzjy tsçwfbgbb ygttwfy fsa vatbwby roz cku divykcvaéy, uiz
cg doaj j'wb étébkph lfyvwvlzkt, azaxsvu rgiz voibic j'kbbjxxotck. Roz jdgaxck,
no augvwwa Rkbkzrpgpfxg Dwnijsz euws tjy fscq vtsufèxgg ujywfmv jg zi lncbazt
Vvm Copqwctuvqwk Rcilngf (ma) gxovu ijoytk uéecjtes lj tqajwku. Zi vzchqzt
Oooakvwk Iogzlv lcwb kk oêam nbgq t'nrdiu Cku Qpntvg unmpéhqxagg lt swgqlogb
Rjgp-Aqlngz Rnxts. Iukpqqóa jédibj ygg bwgpgufyuwway roz ck ocb jyrooaun «
¡Objtewóv! ».

%gLqfunzu

Zmv yvobfupg lj tqajwku gcfbgbb vuwjmaz wb nzxoob voodtj. Rg dzécafs wt
r'kbbwufikuoqb l'ttg hzntuaqvykcv ftezcu aps azxvs l'fjgbbflkovu www xjav
dzjtffm ttg twwsg bcbéxkecj uw qwkék (ecubk « Eviwrks Qajko Wvicf » wt « 250
250 250 »), jgg xgxcgmv icfilzétwauosimv (« ¡Gvsvloóp! », « 1234567890 », sbl.)
uw rmv yqba za rvznygg utykqicku (diw kzsuyrg Hpj Rkbkzrpgpfxg Dwnijsz za
Oooakvwk Iogzlv). Rg dzécafs xjav êhzj xéréhé xjtfovu ap qmwzcwv ukoda nbcbb
xag zm bkugihk ps lémavs.

Tj iqfxv jw amvycum jyv gwtbgbb yxéeéré xnx n'ovaupqm kk uo bnonzm. Ck osavgis
mvz gbatovs bwgpgufy, uccv rc twwsg rm hxqixjy fs ytgvfm za ewvx ijwnixgg wt
rghbwku sv nrrvimkv fikoq (jwfd cfbflkqqjrnsa) za Oczvk. Nsa hxqixjy ucvu
zadqxagamaz tédébév. Igfbnopsa vzchqztu svsuksvu vnia k'ap amvycum ygt
hzntuaqvykcv.

Nvtèg tjy osavgisa, cku gbnzkcvv gpbwaigbb cg hwv kku hzntuaqvykcvv jg rqsktgmv
lcçcvv, iqauj r'éowavoqb lt sqh « nft » (qi v'fsrczuk simcrg jiwochqzt fovv rc
ziamws cuonwaéj), uw rc hxqixj "GT" sv uéréifiynks. Kjxvoqaku gbnzkcvv, zqib
ygthqlanwèzjsgbb lknzmv ww'cv ykpgm yxqjmaot rm c'gpqqjtps Caoqb azbkéhqxag,
qwainimaz roz ttg gézfk fs héwuu ; r'itztsa uktaqakph xnx fs tn swgqxag cc
k'gwhzjy ucvv.

%nVcsjt

Gb dzoew ca hksv béxkhé : ZUTWBWHJNSVJHOQCFYKGTCTT
Hzzaxé giay n'oqkk fs llufs.nw ighbj lqwa-lo !"""

from unicodedata import normalize


def tolet(x):
    "transforme l'entier [x] en la [x]ième lettre majuscule (modulo 26)"
    return chr(65 + x % 26)


def toint(c):
    "tranforme la lettre majuscule [c] en sa position dans l'alphabet (de 0 à 25)"
    return ord(c) - 65


def shift(c, d):
    """décale la lettre [c] de k positions dans l'alphabet (modulo 26)
     où [k] est la position de la lettre [d] dans l'alphabet"""
    return tolet(toint(c) + toint(d))


def unshift(c, d):
    """décale la lettre [c] de k positions dans l'alphabet (modulo 26)
     où [k] est la position de la lettre [d] dans l'alphabet"""
    return tolet(toint(c) - toint(d))

def extraireSousTextes2(m,k):
    lesTextes = [""]*k
    for i in range(len(m)):
        lesTextes[i%k]+=m[i]
    return lesTextes

def ic(freq):
    n=0
    icSum=0
    for x in freq:
        nx=freq[x]  # nombre d'occurences du caractère x
        n=n+nx
        icSum+= nx*(nx-1)
    ic = icSum/(n*(n-1))
    return ic


def calculICMoyen(textes):
    resultat = 0.0
    freq = {}
    icTotal = 0
    for mot in textes:
        freq = {}
        for c in mot:
            freq[c] = freq.get(c, 0) + 1
        icTotal += ic(freq)
    ##ic

    return icTotal / len(textes)

def nettoie(m):
    "nettoie la chaîne [m] en ne gardant que les lettres débarassées de leurs accents et passées en majuscules"
    return ''.join([c for c in normalize('NFKD',m).upper().strip() if ord(c)>64 and ord(c)<91])


def trouveLeE(texte):
    freq = {}
    for mot in texte:
        ##frequence
        for x in mot:
            freq[x] = freq.get(x, 0) + 1
    l = [(freq[c], c) for c in freq]
    l.sort(reverse=True)
    return l[0][1]


def calculerDecalage(texte):
    return (toint(trouveLeE(texte)) - toint('E')) % 26


def calculerDecalages(textes):
    return [calculerDecalage(i) for i in textes]

def constructionCle(decalages):
    return ''.join((tolet(i)) for i in decalages)

def chiffrementVigenere(texteClair,cle):
    texteClair=''.join([x for x in texteClair if x.isalpha()]).upper()
    chiffre =''
    i = 0
    while i<len(texteClair):
        for c in cle:
            ##chiffre+=tolet((toint(texteClair[i])+toint(c))%26)
            chiffre+=shift(texteClair[i],c)
            i+=1
            if not(i<len(texteClair)):
                return chiffre
    return chiffre

def constructionCleDechiffrement(cle):
    return ''.join(tolet((26-toint(i))%26) for i in cle)

def remettreEnForme(textdechiffre,texts : list):
    letexte=""
    index=0
    for i in texts:
        for j in range(len(i)-1):
            if(i[j].isalpha()):
                letexte+=textdechiffre[index]
                index+=1
            else:
                letexte+=i[j]
        letexte+="\n"
    return letexte



if __name__ == "__main__":
    """reader = open("message.vig", "r")
    txt1 = reader.readlines()
    txt=txt1.copy()
    """
    txt=message
    """for i in txt :
        i = i[:-1]
    texte = "".join(txt)"""
    texte = nettoie(message)
    print(texte)
    n=1000
    for i in range(1,4000):
        moyen = calculICMoyen(extraireSousTextes2(texte,i))
        #print(moyen," ",i)
        if(moyen>0.050):
            n = min(i,n)
            print(moyen," ",i)
    #reader.close()
    print(n)

    #liste = extraireSousTextes2(texte,n)

    #cle = constructionCle(calculerDecalages(liste))
    #textedechiffre = chiffrementVigenere(texte,constructionCleDechiffrement(cle))

    #print(remettreEnForme(textedechiffre,txt))







"""

def traduction(text,num):
    textTraduit = ''
    for i in text:
        if (i.islower() and i.isalpha()):
            textTraduit += chr(97 + (ord(i) - num - 97) % 26)
        elif (not (i.islower()) and i.isalpha()):
            textTraduit += chr(65 + (ord(i) - num - 65) % 26)
        else:
            textTraduit += i
    return textTraduit



if __name__ == '__main__':
    for i in (range(27)):
        #print(traduction(message,i)[:20])
        pass

    print(message.translate(str.maketrans('', 'letokenest')))"""